@using Microsoft.AspNetCore.SignalR.Client
@using Riddle.Web.Hubs
@using Riddle.Web.Services
@using Riddle.Web.Components.Shared
@using Flowbite.Components
@inherits RealtimeBaseComponent

@* Display-only combat tracker - combat is controlled by LLM via tools *@
<Card Size="CardSize.ExtraLarge" class="max-w-none" data-testid="combat-tracker">
    <div class="p-4">
        <div class="flex items-center justify-between mb-3">
            <h3 class="font-bold text-gray-900 dark:text-white flex items-center gap-2">
                <span class="text-lg">‚öîÔ∏è</span>
                Combat Tracker
            </h3>
            @if (Combat?.IsActive == true)
            {
                <Badge Color="BadgeColor.Pink" Size="BadgeSize.Small" data-testid="round-number">Round @Combat.RoundNumber</Badge>
            }
        </div>
        
        @if (Combat?.IsActive != true)
        {
            <div class="text-center text-gray-500 dark:text-gray-400 py-4">
                <div class="text-3xl mb-2">üõ°Ô∏è</div>
                <p class="text-sm">No active combat</p>
                <p class="text-xs mt-1 italic">The DM will initiate combat when enemies appear</p>
            </div>
        }
        else
        {
            <div class="space-y-1">
            @foreach (var (combatant, index) in Combat.TurnOrder.Select((c, i) => (c, i)))
            {
                var pcCharacter = combatant.Type == "PC" ? PartyCharacters.FirstOrDefault(c => c.Id == combatant.Id) : null;
                <CombatantCard 
                    Combatant="combatant" 
                    Position="@(index + 1)"
                    IsCurrentTurn="@(index == Combat.CurrentTurnIndex)"
                    IsDm="IsDm"
                    PcDeathSaveSuccesses="@(pcCharacter?.DeathSaveSuccesses ?? 0)"
                    PcDeathSaveFailures="@(pcCharacter?.DeathSaveFailures ?? 0)"
                    IsPcStable="@(pcCharacter?.IsStable ?? false)"
                    IsPcDead="@(pcCharacter?.IsDead ?? false)" />
            }
        </div>
        
            @if (IsDm)
            {
                <p class="text-xs text-gray-500 dark:text-gray-400 text-center italic mt-2">
                    Combat managed via chat
                </p>
            }
        }
    </div>
</Card>

@code {
    [Parameter] 
    public Guid CampaignId { get; set; }
    
    [Parameter] 
    public CombatStatePayload? Combat { get; set; }
    
    [Parameter] 
    public EventCallback<CombatStatePayload?> CombatChanged { get; set; }
    
    [Parameter] 
    public bool IsDm { get; set; }
    
    [Parameter]
    public List<Riddle.Web.Models.Character> PartyCharacters { get; set; } = [];
    
    [Inject]
    private ILogger<CombatTracker> ComponentLogger { get; set; } = null!;

    protected override async Task OnInitializedAsync()
    {
        await SetupSignalR();
    }

    private async Task SetupSignalR()
    {
        try
        {
            // Use base class method to get Docker-aware SignalR URL
            CreateHubConnection();

            HubConnection!.On<CombatStatePayload>(GameHubEvents.CombatStarted, async payload =>
            {
                ComponentLogger.LogWarning("[CombatTracker] CombatStarted SignalR event RECEIVED for campaign {CampaignId}", CampaignId);
                // Don't modify Combat directly - it's a [Parameter] owned by parent
                // Just invoke the callback to notify parent to update its state
                await InvokeAsync(async () =>
                {
                    await CombatChanged.InvokeAsync(payload);
                });
            });

            HubConnection.On<TurnAdvancedPayload>(GameHubEvents.TurnAdvanced, async payload =>
            {
                ComponentLogger.LogDebug("[CombatTracker] TurnAdvanced SignalR event RECEIVED: Round={RoundNumber}, newIndex={NewIndex}", payload.RoundNumber, payload.NewTurnIndex);
                if (Combat != null)
                {
                    // Create updated state with both turn index and round number
                    var updatedState = Combat with { CurrentTurnIndex = payload.NewTurnIndex, RoundNumber = payload.RoundNumber };
                    await InvokeAsync(async () =>
                    {
                        await CombatChanged.InvokeAsync(updatedState);
                    });
                }
            });

            HubConnection.On(GameHubEvents.CombatEnded, async () =>
            {
                ComponentLogger.LogWarning("[CombatTracker] CombatEnded SignalR event RECEIVED for campaign {CampaignId}", CampaignId);
                ComponentLogger.LogWarning("[CombatTracker] Current Combat state before clear: IsActive={IsActive}, TurnOrder={TurnOrderCount}", 
                    Combat?.IsActive, Combat?.TurnOrder?.Count);
                
                // Don't modify Combat directly - it's a [Parameter] owned by parent
                // Just invoke the callback to notify parent to update its state
                await InvokeAsync(async () =>
                {
                    await CombatChanged.InvokeAsync(null);
                    ComponentLogger.LogWarning("[CombatTracker] CombatChanged callback invoked successfully");
                });
            });
            
            // Subscribe to character state updates (HP changes during combat)
            HubConnection.On<CharacterStatePayload>(GameHubEvents.CharacterStateUpdated, async payload =>
            {
                await HandleCharacterStateUpdateAsync(payload);
            });
            
            // Subscribe to death save updates to refresh PC death save UI
            HubConnection.On<DeathSavePayload>(GameHubEvents.DeathSaveUpdated, async payload =>
            {
                ComponentLogger.LogDebug("[CombatTracker] DeathSaveUpdated: {CharacterName} - S:{Successes}/F:{Failures}, Stable:{IsStable}, Dead:{IsDead}",
                    payload.CharacterName, payload.DeathSaveSuccesses, payload.DeathSaveFailures, payload.IsStable, payload.IsDead);
                
                // Trigger UI refresh - the parent component should have updated PartyCharacters
                await InvokeAsync(StateHasChanged);
            });

            await HubConnection.StartAsync();
            
            // Join campaign group to receive combat updates
            if (CampaignId != Guid.Empty)
            {
                await HubConnection.SendAsync("JoinCampaign", CampaignId, "", null, IsDm);
            }
        }
        catch (Exception ex)
        {
            ComponentLogger.LogError(ex, "Failed to setup SignalR connection for CombatTracker");
        }
    }

    private async Task HandleCharacterStateUpdateAsync(CharacterStatePayload payload)
    {
        // Only handle HP updates when combat is active
        if (Combat?.IsActive != true || Combat.TurnOrder == null)
            return;
        
        // Check if this is an HP update (ToolExecutor sends "current_hp" in snake_case)
        if (!string.Equals(payload.Key, "current_hp", StringComparison.OrdinalIgnoreCase))
            return;
        
        // Find the combatant in the turn order by character ID
        var combatantIndex = Combat.TurnOrder.FindIndex(c => 
            c.Id == payload.CharacterId);
        
        if (combatantIndex < 0)
        {
            ComponentLogger.LogDebug("[CombatTracker] CharacterStateUpdated: Character {CharacterId} not in combat turn order", payload.CharacterId);
            return;
        }
        
        // Parse the new HP value
        if (!int.TryParse(payload.Value?.ToString(), out var newHp))
        {
            ComponentLogger.LogWarning("[CombatTracker] CharacterStateUpdated: Could not parse HP value '{Value}' for {CharacterId}", payload.Value, payload.CharacterId);
            return;
        }
        
        ComponentLogger.LogDebug("[CombatTracker] CharacterStateUpdated: Updating {CharacterName} HP to {NewHp}", 
            Combat.TurnOrder[combatantIndex].Name, newHp);
        
        // Create a new turn order list with the updated combatant
        var updatedTurnOrder = Combat.TurnOrder.Select((c, i) => 
            i == combatantIndex 
                ? c with { CurrentHp = newHp } 
                : c
        ).ToList();
        
        // Create updated combat state and notify parent
        var updatedCombat = Combat with { TurnOrder = updatedTurnOrder };
        
        await InvokeAsync(async () =>
        {
            await CombatChanged.InvokeAsync(updatedCombat);
        });
    }
    
    public override async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            try
            {
                if (CampaignId != Guid.Empty)
                {
                    await HubConnection.SendAsync("LeaveCampaign", CampaignId);
                }
            }
            catch (Exception ex)
            {
                ComponentLogger.LogWarning(ex, "Error leaving campaign group");
            }
        }
        
        // Call base to dispose the HubConnection
        await base.DisposeAsync();
    }
}
